package middleware

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"github.com/gin-gonic/gin"
	"github.com/maribowman/gin-skeleton/app/model"
	"net/http"
	"strconv"
	"time"
)

/*
If enabled, all API requests must be signed and contain the following headers:
	- key: 			The api key as string
	- signature:	The user generated signature
  	- timestamp:	The number of seconds (UTC) since Unix Epoch
The signature header is generated by creating a SHA256 HMAC using the secret key on the pre-hash string `timestamp + method + requestPath`.
Your timestamp must be within 30 seconds of the API service time or your request will be considered expired and rejected.

Postman
Header:
	- key: testKey
	- timestamp: {{timestampUTC}}
	- signature: {{signature}}

Pre-request Script:
``` js
var timestampUTC = Math.floor(new Date().getTime()/1000).toString();
pm.environment.set("timestampUTC", timestampUTC);
pm.environment.set("signature", CryptoJS.HmacSHA256(timestampUTC + pm.request.method.toString() + path, 'testSecret').toString(CryptoJS.digest));
```
*/

func HmacMiddleware(authEnabled bool, allowsUsers []model.User) gin.HandlerFunc {
	if authEnabled {
		return func(context *gin.Context) {
			key := context.GetHeader("key")
			signature := context.GetHeader("signature")
			timestamp := context.GetHeader("timestamp")
			if len(key) == 0 || len(signature) == 0 || len(timestamp) == 0 {
				context.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"error": "authentication headers not complete"})
				return
			}
			if secret, ok := getSecretForUserKey(key, allowsUsers); ok {
				timestampInteger, err := strconv.ParseInt(timestamp, 10, 64)
				if err != nil {
					context.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "invalid timestamp"})
					return
				}
				// request older than 30"
				if time.Unix(timestampInteger, 0).Add(30 * time.Second).Before(time.Now().UTC()) {
					context.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "timestamp too old"})
					return
				} else if time.Unix(timestampInteger, 0).After(time.Now().UTC()) {
					context.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "timestamp in the future"})
					return
				}
				sigHash := hmac.New(sha256.New, secret)
				sigHash.Write([]byte(timestamp + context.Request.Method + context.Request.URL.Path))
				if hmac.Equal([]byte(signature), []byte(hex.EncodeToString(sigHash.Sum(nil)))) {
					context.Next()
				} else {
					context.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid signature"})
					return
				}
			} else {
				context.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid key"})
				return
			}
		}
	}
	return nil
}

func getSecretForUserKey(key string, allowsUsers []model.User) ([]byte, bool) {
	for _, user := range allowsUsers {
		if key == user.Key {
			secret, err := base64.StdEncoding.DecodeString(user.Secret)
			if err != nil {
				return nil, false
			}
			return secret, true
		}
	}
	return nil, false
}
